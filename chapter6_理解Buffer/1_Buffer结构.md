文件和网 络I/O对于前端开发者而言都是不曾有的应用场景，因为前端只需做一些简单的字符串操作或 DOM操作基本就能满足业务需求，在ECMAScript规范中，也没有对这些方面做任何的定义，只 有CommonJS中有部分二进制的定义。

由于应用场景不同，**在Node中，应用需要处理网络协议、 操作数据库、处理图片、接收上传文件等，在网络流和文件的操作中，还要处理大量二进制数据， JavaScript自有的字符串远远不能满足这些需求，于是Buffer对象应运而生。**

### 模块结构

Buffer 是一个典型的 JavaScript 与 C++ 结合的模块，它将性能相关部分用 C++ 实现，将非性能相关的部分用JavaScript 实现。

第 5 章揭示了 Buffer 所占用的内存不是通过 V8 分配的，属于堆外内存。由于 V8 垃圾回收性能的影响，将常用的操作对象用更高效和专有的内存分配回收策略来管理是个不错的思路。

由于 Buffer 太过常见，Node在进程启动时就已经加载了它，并将其放在全局对象（global） 上。所以在使用Buffer 时，无须通过 require() 即可直接使用。

### Buffer对象

Buffer对象类似于数组，它的元素为 16 进制的两位数，即 0 到 255 的数值。示例代码如下所示：

```javascript
var str = "深入浅出node.js"; 
var buf = new Buffer(str, 'utf-8'); 
console.log(buf); 
// => <Buffer e6 b7 b1 e5 85 a5 e6 b5 85 e5 87 ba 6e 6f 64 65 2e 6a 73> 
```

由上面的示例可见，不同编码的字符串占用的元素个数各不相同，上面代码中的中文字在 UTF-8 编码下占用 3 个元素，字母和半角标点符号占用1个元素。

Buffer受Array类型的影响很大，可以访问length属性得到长度，也可以通过下标访问元素， 在构造对象时也十分相似，代码如下

```javascript
var buf = new Buffer(100); 
console.log(buf.length); // => 100 
```

上述代码分配了一个长100字节的Buffer对象。可以通过下标访问刚初始化的Buffer的元素， 代码如下：

```javascript
console.log(buf[10]); 
```

这里会得到一个比较奇怪的结果，它的元素值是一个0到255的随机值。 同样，我们也可以通过下标对它进行赋值：

```javascript
buf[10] = 100; 
console.log(buf[10]); // => 100
```

值得注意的是，如果给元素赋值不是0到255的整数而是小数时会怎样呢？示例代码如下所示：

```javascript
buf[20] = -100; 
console.log(buf[20]); // 156 
buf[21] = 300; 
console.log(buf[21]); // 44 
buf[22] = 3.1415; 
console.log(buf[22]); // 3
```

给元素的赋值如果小于0，就将该值逐次加 256，直到得到一个 0 到 255 之间的整数。如果得到的数值大于 255，就逐次减 256，直到得到 0~255 区间内的数值。如果是小数，舍弃小数部分，只 保留整数部分。

### Buffer内存分配

Buffer对象的内存分配不是在V8的堆内存中，而是在Node的C++层面实现内存的申请的。因为处理大量的字节数据不能采用需要一点内存就向操作系统申请一点内存的方式，这可能造成大 量的内存申请的系统调用，对操作系统有一定压力。**为此Node在内存的使用上应用的是在C++ 层面申请内存、在JavaScript中分配内存的策略。**

为了高效地使用申请来的内存，Node 采用了 slab 分配机制。slab 是一种动态内存管理机制，最早诞生于 SunOS 操作系统（Solaris）中，目前在一些*nix操作系统中有广泛的应用，如 FreeBSD 和 Linux。

简单而言，slab就是一块申请好的固定大小的内存区域。slab具有如下3种状态。

- full：完全分配状态
- partial：部分分配状态
- empty：没有被分配状态。

当我们需要一个 Buffer 对象，可以通过以下方式分配指定大小的 Buffer 对象：

```javascript
new Buffer(size); 
```

Node 以 8 KB 为界限来区分 Buffer 是大对象还是小对象：

```javascript
Buffer.poolSize = 8 * 1024; 
```

这个 8 KB 的值也就是每个 slab 的大小值，在 JavaScript 层面，以它作为单位单元进行内存的分配。

#### 分配小Buffer对象

于同一个slab可能分配给多个Buffer对象使用，只有这些小Buffer对 象在作用域释放并都可以回收时，slab的8 KB空间才会被回收。尽管创建了1个字节的Buffer对象， 但是如果不释放它，实际可能是8 KB的内存没有释放。

#### 分配大Buffer对象

上面提到的Buffer对象都是JavaScript层面的，能够被V8的垃圾回收标记回收。但是其内部的 parent属性指向的SlowBuffer对象却来自于Node自身C++中的定义，是C++层面上的Buffer对象， 所用内存不在V8的堆中。

#### 小结 

简单而言，真正的内存是在 Node 的 C++ 层面提供的，JavaScript 层面只是使用它。当进行小而频繁的 Buffer 操作时，采用 slab 的机制进行预先申请和事后分配，使得 JavaScript 到操作系统之间 不必有过多的内存申请方面的系统调用。对于大块的 Buffer 而言，则直接使用 C++ 层面提供的内存，而无需细腻的分配操作。