在使用 Node 进行实际的项目开发之前，我内心也曾十分忐忑。尽管 JavaScript 历史悠久，但相较成熟的后端语言而言，Node 尚且算是新晋同学。甚至对于前端，因为各种各样的原因， JavaScript 的测试都十分少。Node 编写的在线产品，在成千上万用户面前能否具备良好的质量保证，我是心存疑问的。

在使用 Node 进行实际的项目开发之前，我内心也曾十分忐忑。尽管 JavaScript 历史悠久，但相较成熟的后端语言而言，Node 尚且算是新晋同学。甚至对于前端，因为各种各样的原因， JavaScript 的测试都十分少。Node 编写的在线产品，在成千上万用户面前能否具备良好的质量保证，我是心存疑问的。

测试的意义在于，在用户消费产出的代码之前，开发者首先消费它，给予其重要的质量保证。 这里值得提醒的是，JavaScript 开发者需要转变观念，正视自己的代码，对自己产出的代码负责。 为自己的代码写测试用例则是一种行之有效的方法，它能够让开发者明确掌握到代码的行为和性能等

测试包含单元测试、性能测试、安全测试和功能测试等几个方面，**本章将从 Node 实践的角度来介绍单元测试和性能测试。**

### 单元测试

**单元测试在软件项目中扮演着举足轻重的角色，是几种软件质量保证的方法中投入产出比最高的一种。**尽管在过去的 JavaScript 开发中，绝大多数人都忽视了这个环节，但今天 Node 的盛行让我们不得不重新审视这块领域。

#### 单元测试的意义

这里需要倡导的是，开发者应该吃自己的狗粮。项目成员共同开发出来的代码会构成项目的 产品，开发者写出来的代码是开发者自己的产品。要保证产品的质量，就应该有相应的手段去验证。对于开发者而言，单元测试就是最基本的一种方式。如果开发者不自己测试代码，那必然要面对如下问题。

**测试工程师是否可依赖？**

- 第一个层面是测试工程师是否熟悉 Node 领域，不了解一个领域而只凭借过往经验来对这个项目进行测试，有可能演变为敷衍的行为，这对质量保证的目标背道而驰。
- 另一个层面是，如果存在人事变动等原因，可能并不一定覆盖到开发者的代码，从而使测试用例的维护成本变高。

**第三方代码是否可信赖？**

- 对于Node开源社区而言（共有3万多模块），作为一个不知名的开发者，其产出的模块如果连单元测试都没有提供，使用者在挑选模块时，内心也会闪过多个“靠谱吗”的疑问。

**在产品迭代过程中，如何继续保证质量？**

- **单元测试的意义在于每个测试用例的覆盖都是一种可能的承诺。如果API升级时，测试用例可以很好地检查是否向下兼容。对于各种可能的输入，一旦测试覆盖，都能明确它的输出。代码改动后，可以通过测试结果判断代码的改动是否影响已确定的结果。**
- 另一个对单元测试持疑的观点是，如果要在项目中进行单元测试，那么势必会影响开发者的项目进度。这个答案是肯定的，因为**产出品质可以久经考验的产品，必然要花费较多的精力。如果只是豆腐渣工程，自然可以快速产出。区别在于后续维护的差异，因为有单元测试的质量保证， 可以放心地增加和删除功能。后者则会陷入举步维艰的维护之路，拆东墙补西墙，开发者也渐渐变得只想做新项目，而旧的项目最后变得不可维护，或者不敢维护。甚至到项目下线时，依然充斥幽灵代码和重复代码。**
- 单元测试只是在早期会多花费一定的成本，但这个成本要远远低于后期深陷维护泥潭的投入。至于是选择在早期投入成本还是在后期投入，只是朝三暮四还是朝四暮三的选择。

**展开介绍单元测试之前，需要提及的问题是代码的可测试性**

它是能够为其编写单元测试的前提条件。复杂的逻辑代码充满各种分支和判断，甚至像面条一样乱作一团，要对它们进行测试， 难度相当大。一个感觉就是当无法为一段代码写出单元测试时，这段代码必然有坏味道，这会为开发者带来心理压力，这样的代码最需要重构。好代码的单元测试必然是轻量的，重构和写单元测试之间是一个相互促进的步骤，当重构代码的压力比较小的时候，也就意味着代码比较稳定， 代码的可测试性越好，甚至代码越简洁。

**简单而言，编写可测试代码有以下几个原则可以遵循。**

- 单一职责。如果一段代码承担的职责越多，为其编写单元测试的时候就要构造更多的输 入数据，然后推测它的输出。比如，一段代码中既包含数据库的连接，也包含查询，那么为它编写测试用例就要同时关注数据库连接和数据库查询。较好的方式是将这两种职责进行解耦分离，变成两个单一职责的方法，分别测试数据库连接和数据库查询。
- 接口抽象。通过对程序代码进行接口抽象后，我们可以针对接口进行测试，而具体代码 实现的变化不影响为接口编写的单元测试。 
- 层次分离。层次分离实际上是单一职责的一种实现。在 MVC 结构的应用中，就是典型的层次分离模型，如果不分离各个层次，无法想象这个代码该如何切入测试。通过分层之 后，可以逐层测试，逐层保证。

**对于开发者而言，不仅要编写单元测试，还应当编写可测试代码。**

#### 单元测试介绍

单元测试主要包含**断言、测试框架、测试用例、测试覆盖率、mock、持续集成**等几个方面， 由于Node的特殊性，它还会加入**异步代码测试和私有方法的测试**这两个部分。

**断言**

**测试框架**

**测试代码的文件组织**

 **测试用例**

**测试覆盖率**

**mock**

**私有方法的测试**

### 工程化与自动化

Node 以及第三方模块提供的方法都相对偏底层，在开发项目时，还需要一定的工具来实现工程化和自动化（这里我们介绍其中的一种方式——持续集成），以减少手工成本。

#### 工程化

Node 在 *nix 系统下可以很好地利用一些成熟工具，其中 Makefile 比较小巧灵活，适合用来构建工程。

```javascript
TESTS = test/*.js 
REPORTER = spec 
TIMEOUT = 10000 
MOCHA_OPTS = 
test: 
 @NODE_ENV=test ./node_modules/mocha/bin/mocha \ 
 --reporter $(REPORTER) \ 
 --timeout $(TIMEOUT) \ 
 $(MOCHA_OPTS) \ 
 $(TESTS) 
test-cov: 
 @$(MAKE) test MOCHA_OPTS='--require blanket' REPORTER=html-cov > coverage.html 
test-all: test test-cov 
.PHONY: test 
```

开发者改动代码之后，只需通过 make test 和 make test-cov 命令即可执行复杂的单元测试和覆盖率。这里需要注意以下两点。

- Makefile文件的缩进必须是tab符号，不能用空格。 
- 记得在包描述文件中配置blanket。

#### 持续集成

将项目工程化可以帮助我们把项目组织成比较固定的结构，以供扩展。但是对于实际的项目而言，频繁地迭代是常见的状态，如何记录版本的迭代信息，还需要一个持续集成的环境。

至于如何持续集成，各个公司都有自己特定的方案，这里介绍一下社区中比较流行的方式——利用travis-ci实现持续集成。

### 小结

如测试 Web 应用等，读者可以自行查看所用 Web 框架的测试方式，比如 Connect 或 Express 提供了 supertest 辅助库来简化单元测试的编写。 

**在项目中经常会因为依赖方的变化而产生业务代码的跟随变动，如果没有单元测试的覆盖，依赖方逻辑发生变化后，很难定位该变动影响的范围。一旦为项目覆盖完善的单元测试， 项目的状态将会因为测试报告而了然于心。完善的单元测试在一定程度上也昭示着项目的成熟度。**

