### JavaScript 的发展简介

JavaScript 一开始没有人把他当作一门真正的编程语言，认为它这是一个网页小脚本而已。在Web 1.0时代，这种脚本语言在网络中主要有两个作用广为流传，一个是表单校验， 另一个是网页特效。

另一方面，由于仓促地被创造出来，所以它自身的各种陷阱和缺点也被各种 编程人员广为诟病。

直到Web 2.0时代，前端工程师利用它大大提升了网页上的用户体验。在这 个过程中，B/S应用展现出比C/S应用优越的地方。至此，JavaScript才被广泛重视起来。

在Web 2.0流行的过程中，各种**前端库和框架**被开发出来，它们最初用于**兼容各个版本的浏览器**，随后随着更多的用户需求在前端被实现，JavaScript 也从表单校验跃迁到**应用开发的级别**上。 在这个过程中，它大致经历了**工具类库、组件库、前端框架、前端应用的变迁**。

### 为什么要模块化？

JavaScript 通过 script 标签引入代码的方式显得杂乱无章，语言自身毫无组织和约束能力，人们不得不用命名空间等方式人为地约束代码，以求达到安全和易用的目的。经历十多年的发展后，社区也为 JavaScript 制定了相应的规范，其中 CommonJS 规范的提出算是最为重要的里程碑。

## CommonJS 规范

### 什么是 CommonJS 规范

CommonJS 规范涵盖了**模块、二进制、Buffer、字符集编码、I/O流、进程环境、文件系统、套接字、单元测试、Web服务器网关接口、 包管理**等。

CommonJS 规范为 JavaScript 制定了一个美好的愿景——希望JavaScript能够在任何地方运行。

ECMAScript 规范化的时间较早，规范涵盖的范畴非常小。这些规范 JavaScript 语言的基本要素。在Web 1.0时代，只有对DOM、BOM等基本的支持。

Web 2.0 在浏览器中出现了更多、更强大的 API 供 JavaScript 调用，但后端 JavaScript 的规范却远远落后。对于JavaScript 自身而言，它的规范依然是薄弱的，还有以下缺陷。

- 没有模块系统
- 标准库较少
- 没有标准接口
- 缺乏包管理系统

**CommonJS 规范的提出，主要是为了弥补当前JavaScript没有标准的缺陷，以达到像 Python、 Ruby 和 Java具备开发大型应用的基础能力，而不是停留在小脚本程序的阶段。**

他们期望那些用 CommonJS API 写出的应用可以具备跨宿主环境执行的能力，这样不仅可以利用 JavaScript 开发富 客户端应用，而且还可以编写以下应用：

- 服务器端JavaScript应用程序。 

- 命令行工具。 

- 桌面图形界面应用程序。 

- 混合应用（Titanium和Adobe AIR等形式的应用）

**Node 与浏览器以及 W3C 组织、CommonJS 组织、ECMAScript 共同构成了一 个繁荣的生态系统。**

Node借鉴 CommonJS 的 Modules 规范实现了一套非常易用的模块系统，NPM 对 Packages 规范 的完好支持使得Node应用在开发过程中事半功倍。在本章中，我们主要就 Node 的模块和包的实现进行展开说明。

### CommonJS 的模块规范

CommonJS对模块的定义十分简单，主要分为模块引用、模块定义和模块标识3个部分。

- 模块引用：var math = require('math'); 
- 模块定义：exports.add = fuction() { ... }；在另一个文件中，我们通过require()方法引入模块后，就能调用定义的属性或方法了。
- 模块标识：模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者以.、..开头的相对路径，或者绝对路径。它可以没有文件名后缀 .js。每个模块具有独立的空间，它们互不干扰，在引用时也显得干净利落。

### Node 的模块实现

在Node中引入模块，需要经历如下3个步骤。 

1. 路径分析
2. 文件定位
3. 编译执行

在Node中，模块分为两类：一类是Node提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。

-  核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存中，所以这部分**核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的。**
- 文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。

#### 优先从缓存加载

与前端浏览器会缓存静态脚本 文件以提高性能一样，Node对引入过的模块都会进行缓存，以减少二次引入时的开销。

不同的地方在于，浏览器仅仅缓存文件，而 Node 缓存的是编译和执行之后的对象。

**不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的 方式，这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查。**

### 路径分析和文件定位

#### 路径定位

模块标识符主要分为以下几类：

- 核心模块
- .或../开始的相对路径文件模块
- 以/开始的绝对路径文件模块
- 非路径形式的文件模块

核心模块已经被编译成了二进制代码

非路径形式的文件模块：

- 当前文件目录下的node_modules目录。
- 父目录下的node_modules目录。
- 父目录的父目录下的node_modules目录。
- 沿路径向上逐级递归，直到根目录下的node_modules目录。

#### 文件定位

**缓存加载的优化策略使得二次引入时不需要路径分析、文件定位和编译执行的过程**，大大提高了再次加载模块时的效率。

还有一些细节需要注意，这主要包括文件扩展名的分析、目录和包的处理。

Node会按.js、.json、.node的次序补足扩展名。

- 所以如果是 .node 或者是 .json 的文件，带上扩展名会加快一点速度。
- 同步配合缓存，可以大幅度缓解 Node 单线程中阻塞式调用的问题。

 **目录分析和包**

require()通过分析文件扩展名之后，可能没有查找到对应文件，但却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，此时**Node会将目录当做一个包来处理。**

**Node在当前目录下 查找package.json（CommonJS包规范定义的包描述文件），通过JSON.parse()解析出包描述对象， 从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。**

而如果main属性指定的文件名错误，或者压根没有package.json文件，Node会将index当做默 认文件名，然后依次查找index.js、index.json、index.node

如果在目录分析的过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查 找。如果模块路径数组都被遍历完毕，依然没有查找到目标文件，则会抛出查找失败的异常。

### 模块编译

在 Node 中，每一个模块都是一个对象。的味道具体的文件之后，Node 会新建一个模块对象，然后根据路径载入并且编译。对于不同的文件扩展名，载入方法也有所不同，具体如下所示：

- **js 文件，通过 fs 模块，同步读取文件后编译执行。**
- **json文件。通过fs模块同步读取文件后，用JSON.parse()解析返回结果。**
-  .node文件。这是用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件。
- 其余扩展名文件。它们都被当做.js文件载入。

每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二 次引入的性能。

**官方不鼓励进行自定义扩展名的加载，而是期望先将其他语言或文件编译成JavaScript文件后再加载，这样做的好处在于不将烦琐的编译加载等过程引入Node的执行过程中。**

**1、 JavaScript模块的编译**

exports, require, module,  __filename, _dirname 从何而来？事实上，在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。

```javascript
(function (exports, require, module, __filename, __dirname) { 
 var math = require('math'); 
 exports.area = function (radius) { 
 return Math.PI * radius * radius; 
 }; 
}); 

```

为何存在 exports 的情况下，还存在 module.exports ？

exports 作为形参传入，直接赋值会使对应的实参 exports 被覆盖，而给 module.exports 赋值却只是添加属性

**2、C/C++模块的编译**

略

**3、JSON文件的编译**

Node 利用 fs 模块同步读取 JSON 文件的内容之 后，调用 JSON.parse() 方法得到对象，然后将它赋给模块对象的 exports

#### 核心模块编译

分为 JavaScript 核心模块的编译过程和 C/C++ 核心模块的编译过程

#### 编写核心模块

略

####  C/C++扩展模块

分为 C/C++扩展模块的编写和 C/C++扩展模块的编译和 C/C++扩展模块的加载

#### 模块调用栈

JavaScript核心模块主要扮演的职责有两类：一类是作为C/C++内建模块的封装层和桥接层， 供文件模块调用；一类是纯粹的功能模块，它不需要跟底层打交道，但是又十分重要。

### 包结构

包实际上是一个存档文件，即一个目录直接打包为.zip或tar.gz格式的文件，安装后解压还原 为目录。完全符合CommonJS规范的包目录应该包含如下这些文件：

-  package.json：包描述文件。
-  bin：用于存放可执行二进制文件的目录。
-  lib：用于存放JavaScript代码的目录。
-  doc：用于存放文档的目录。
-  test：用于存放单元测试用例的代码。

可以看到，CommonJS包规范从文档、测试等方面都做过考虑。当一个包完成后向外公布时， 用户看到单元测试和文档的时候，会给他们一种踏实可靠的感觉。

#### 包描述文件与NPM 

略

####  NPM常用功能

- npm -v 
- npm

#### 安装依赖包

安装包分为两种方式，第一种是全局模式安装，第二种是从本地安装。此外你还可以选择非官方源安装依赖。

**全局模式安装**

全局模式并不是将一个模块包安装为一个全局包的意思，它并不意味着可以从任 何地方通过require()来引用到它。实际上，-g 是将一个包安装为全局可用的 可执行命令。它根据包描述文件中的bin字段配置，将实际脚本链接到与 Node 可执行文件相同的 路径下：

```javascript
"bin": { 
 "express": "./bin/express" 
}, 
```

事实上，通过全局模式安装的所有模块包都被安装进了一个统一的目录下，这个目录可以通 过如下方式推算出来：

```javascript
path.resolve(process.execPath, '..', '..', 'lib', 'node_modules'); 
```

如果Node可执行文件的位置是/usr/local/bin/node，那么模块目录就是/usr/local/lib/node_  modules。最后，通过软链接的方式将bin字段配置的可执行文件链接到Node的可执行目录下

**从本地安装**

对于一些**没有发布到NPM上的包**，或是**因为网络原因导致无法直接安装的包**，可以通过将包下载到本地，然后以本地安装。

本地安装只需为NPM指明package.json文件所在的位置即可：它 可以是一个包含package.json的存档文件，也可以是一个URL地址，也可以是一个目录下有 package.json文件的目录位置。具体参数如下：

- npm install [tarball file]
- npm install [tarball url]
- npm install [folder]

 **从非官方源安装**

npm install underscore --registry=http://registry.url

可以设置默认的源：

npm config set registry http://registry.url

####  NPM钩子命令

```javascript
"scripts": { 
 "preinstall": "preinstall.js", 
 "install": "install.js", 
 "uninstall": "uninstall.js", 
 "test": "test.js" 
}
```

在以上字段中执行npm install 时，preinstall指向的脚本将会被加载执行，然后 install指向的脚本会被执行。在执行npm uninstall 时，uninstall指向的脚本也许会 做一些清理工作等

当在一个具体的包目录下执行npm test时，将会运行test指向的脚本。一个优秀的包应当包 含测试用例，并在package.json文件中配置好运行测试的命令，方便用户运行测试用例，以便检 验包是否稳定可靠。

#### 发布包

略

#### 分析包

可以执行 **npm ls** 分析包。这个命令可以为你分析出当前路径下能够通过模块路径找到的所有包，并生成依赖树。

