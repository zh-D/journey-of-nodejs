### 异步 I/O 与非阻塞 I/O 

（但其实简单两句话讲完异步IO和非阻塞IO的区别后下面主要的内容其实是区分阻塞和非阻塞 IO）

异步与非阻塞听起来似乎是同一回事。从实际效果而言，异步和非阻塞都达到了我们 并行I/O的目的。**但是从计算机内核I/O而言，异步/同步和阻塞/非阻塞实际上是两回事。**

**操作系统内核对于I/O只有两种方式：阻塞与非阻塞。在调用阻塞I/O时，应用程序需要等待 I/O完成才返回结果。**

**阻塞I/O的一个特点是调用之后一定要等到系统内核层面完成所有操作后，调用才结束**。以读取磁盘上的一段文件为例，系统内核在完成磁盘寻道、读取数据、复制数据到内存中之后，这 个调用才结束。阻塞I/O造成CPU等待I/O，浪费等待时间，CPU的处理能力不能得到充分利用。

**非阻塞 I/O 跟阻塞 I/O 的差别为调用之后会立即返回。非阻塞I/O返回之后，CPU的时间片可以用来处理其他事务，此时的性能提升是明显的。**

**但非阻塞 I/O 也存在一些问题。由于完整的 I/O 并没有完成，立即返回的并不是业务层期望的数据，而仅仅是当前调用的状态。为了获取完整的数据，应用程序需要重复调用I/O操作来确认是否完成。这种重复调用判断操作是否完成的技术叫做轮询。**

反正非阻塞 I/O 先不返回数据，后续要轮询重复调用 IO 操作，以获得完整的数据。

轮询的技术主要有：

- read
- select
- poll
- epoll：该方案是Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到 I/O事件，将会进行休眠，直到事件发生将它唤醒。它是真实利用了事件通知、执行回调 的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高。
- kqueue

### 理想的非阻塞异步I/O

我们期望的**完美的异步I/O应该是应用程序发起非阻塞调用**，无须通过遍历或者事件唤醒等方式轮询，可以直接处理下一个任务，**只需在I/O完成后通过信号或回调将数据传递给应用程序即可。**

幸运的是，在Linux下存在这样一种方式，它原生提供的一种异步I/O方式（AIO）就是通过信号或回调来传递数据的。 但不幸的是，只有Linux下有，而且它还有缺陷——AIO仅支持内核I/O中的O_DIRECT方式读取，导致无法利用系统缓存。

### 现实的异步I/O

前面我们将场景限定在了单线程的状况下，**多线程的方式会是另一番风景。通过让部分线程进行阻塞I/O或者非阻塞 I/O 加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将I/O得到的数据进行传递，这就轻松实现了异步 I/O。**

然后讲了几种多线程的异步IO：

- glibc的AIO
- libeio
- Windows下的IOCP

由于Windows平台和 *nix 平台的差异，Node提供 了libuv 作为抽象封装层，使得所有平台兼容性的判断都由这一层来完成，并保证上层的 Node 与下层的自定义线程池及 IOCP 之间各自独立。

另一个需要强调的地方在于我们时常提到 **Node 是单线程的，这里的单线程仅仅只是 JavaScript 执行在单线程中罢了**。在Node中，无论是*nix还是Windows平台，**内部完成 I/O 任务的另有线程池**。