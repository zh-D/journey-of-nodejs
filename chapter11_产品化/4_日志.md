在真实的项目中，开发只是整个投入的一小部分。应用或系统真正上线运转起来时，问题有可能会接踵而来。所谓智者千虑，必有一疏。无论多么周密的代码编写，一些未知问题总是可能在某个不确定的时候出现。这种情况下，与其遇见 bug 修复它，不如建立健全的排查和跟踪机制， 而日志就是实现这种机制的关键。在健全的系统中，完善的日志记录最能够还原问题现场。通过记录日志来定位问题是一种成本较小的方式。这种非结构化、轻量的记录方式容易实现，也容易扩展。

### 访问日志

访问日志一般用来记录每个客户端对应用的访问。

在 Web 应用中，主要记录 HTTP 请求中的关键数据。一般的 Web 服务器都实现了记录访问日志的功能，只需要简单的配置即可启用。在用 Nginx 或 Apache 进行反向代理时，可以利用这些已有的设施完成访问日志的记录。在 Node 开发的 Web 应用中，也可以自行实现访问日志的记录。

### 异常日志

异常日志通常用来记录那些意外产生的异常错误。通过日志的记录，开发者可以根据异常信息去定位 bug 出现的具体位置，以快速修复问题。

异常日志通常有完善的分级，Node中提供的console对象就简单地实现了这几种划分，具体 如下所示。

- console.log：普通日志。 
- console.info：普通信息。 
- console.warn：警告信息。 
- console.error：错误信息。

### 日志与数据库

但是日志文件与数据库写入在性能上处于两个级别，数据库在写入过程中要经历一系列处 理，比如锁表、日志等操作。写日志文件则是直接将数据写到磁盘上。为此，如果有大量的访问， 可能会存在写入操作大量排队的状况，数据库的消费速度严重低于生产速度，进而导致内存泄漏等。相比之下，写日志是轻量的方法，**将日志分析和日志记录这两个步骤分离开来是较好的选择。 日志记录可以在线写，日志分析则可以借助一些工具同步到数据库中，通过离线分析的方式反馈出来。**

### 分割日志

线上业务可能访问量巨大，产生的日志也可能是大量的，上述示例只是简单地将普通日志和异常日志分开放在两个文件中，日志过多时也不便直接查看。为此，**将产生的日志按日期分割是 一个不错的主意**。日志的写入一般都是依托在可写流上的。对于Console对象，它的内部属性 \_stdout 和\_stderr 就是指向我们传入的两个输入流对象的。在设计的过程中，我们可以按日期传递对应的日志文件可写流对象，为此可以设计一个定时器用于当日期发生更改时，更改日志对象 的两个输入流对象即可。这里将不展开描述具体实现。

### 小结

捕捉日志相对而言是较为烦琐的事情，但是一旦构建好这个基础过程，有问题产生时则可以快速解决。很多开发者在开发过程中完全不（或没来得及）考虑日志，到线上产生问题时则会手忙脚乱。良好的日志可以为系统的长期运行保驾护航，出现任何问题时，我们都能做到心中有数。