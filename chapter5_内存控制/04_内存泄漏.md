Node对内存泄漏十分敏感，**一旦线上应用有成千上万的流量，哪怕是一个字节的内存泄漏也会造成堆积，垃圾回收过程中将会耗费更多时间进行对象扫描，应用响应缓慢，直到进程内存溢出，应用崩溃。**

在V8的垃圾回收机制下，在通常的代码编写中，很少会出现内存泄漏的情况。但是内存泄 漏通常产生于无意间，较难排查。尽管内存泄漏的情况不尽相同，但其实质只有一个，那就是应 当回收的对象出现意外而没有被回收，变成了常驻在老生代中的对象。

通常，造成内存泄漏的原因有如下几个：

- 缓存
- 队列消费不及时
- 作用域未释放。

### 慎将内存当做缓存

缓存在应用中的作用举足轻重，可以十分有效地节省资源。因为它的访问效率要比I/O的效 率高，一旦命中缓存，就可以节省一次I/O的时间。

但是在Node中，缓存并非物美价廉。一旦一个对象被当做缓存来使用，那就意味着它将会常驻在老生代中。**缓存中存储的键越多，长期存活的对象也就越多，这将导致垃圾回收在进行扫描和整理时，对这些对象做无用功**。

JavaScript开发者通常喜欢用对象的键值对来缓存东西，但这与严格意义上 的缓存又有着区别，**严格意义的缓存有着完善的过期策略**，而普通对象的键值对并没有。

如下代码虽然利用JavaScript对象十分容易创建一个缓存对象，但是受垃圾回收机制的影响， 只能小量使用：

```javascript
var cache = {}; 
var get = function (key) { 
 if (cache[key]) { 
 return cache[key]; 
 } else { 
 // get from otherwise 
 } 
}; 
var set = function (key, value) { 
 cache[key] = value; 
}; 
```

上述示例在解释原理后，十分容易理解，如果需要，只要**限定缓存对象的大小，加上完善的过期策略**以防止内存无限制增长，还是可以一用的。

给出一个可能无意识造成内存泄漏的场景：memoize

著名类库 underscore 对 memoize的实现：

```javascript
_.memoize = function(func, hasher) { 
 var memo = {}; 
 hasher || (hasher = _.identity); 
 return function() { 
 var key = hasher.apply(this, arguments); 
 return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments)); 
 }; 
}; 
```

它的原理是以参数作为键进行缓存，以内存空间换CPU执行时间。这里潜藏的陷阱即是每个 被执行的结果都会按参数缓存在memo对象上，不会被清除。这在前端网页这种短时应用场景中不 存在大问题，但是执行量大和参数多样性的情况下，会造成内存占用不释放。

所以在Node中，任何试图拿内存当缓存的行为都应当被限制。当然，这种限制并不是不允许使用的意思，而是要小心为之

#### 缓存限制策略

为了解决缓存中的对象永远无法释放的问题，需要加入一种策略来限制缓存的无限增长。为 此我曾写过一个模块limitablemap，它可以实现对键值数量的限制。下面是其实现：

```javascript
var LimitableMap = function (limit) { 
 this.limit = limit || 10; 
 this.map = {}; 
 this.keys = []; 
}; 
var hasOwnProperty = Object.prototype.hasOwnProperty; 
LimitableMap.prototype.set = function (key, value) { 
 var map = this.map; 
 var keys = this.keys; 
if (!hasOwnProperty.call(map, key)) { 
 if (keys.length === this.limit) { 
 var firstKey = keys.shift(); 
 delete map[firstKey]; 
 } 
 keys.push(key); 
 } 
 map[key] = value; 
}; 
LimitableMap.prototype.get = function (key) { 
 return this.map[key]; 
}; 
module.exports = LimitableMap; 
```

可以看到，实现过程还是非常简单的。记录键在数组中，一旦超过数量，就以先进先出的方 式进行淘汰。

当然，这种淘汰策略并不是十分高效，只能应付小型应用场景。如果需要更高效的缓存，可 以参见Isaac Z. Schlueter 采用 LRU 算法的缓存，地址为https://github.com/isaacs/node-lru-cache。结 合有限制的缓存，memoize 还是可用的。

另一个案例在于模块机制。在第2章的模块介绍中，为了加速模块的引入，所有模块都会通 过编译执行，然后被缓存起来。由于通过exports导出的函数，可以访问文件模块中的私有变量， 这样每个文件模块在编译执行后形成的作用域因为模块缓存的原因，不会被释放。示例代码如下 所示：

```javascript
(function (exports, require, module, __filename, __dirname) { 
 var local = "局部变量"; 
 exports.get = function () { 
 return local; 
 }; 
}); 
```

由于**模块的缓存机制**，模块是常驻老生代的。在设计模块时，要十分小心内存泄漏的出现。 在下面的代码，每次调用leak()方法时，都导致局部变量leakArray不停增加内存的占用，且不被 释放：

```javascript
var leakArray = []; 
exports.leak = function () { 
 leakArray.push("leak" + Math.random()); 
}; 
```

如果模块不可避免地需要这么设计，那么请添加清空队列的相应接口，以供调用者释放内存。

#### 缓存的解决方案

直接将内存作为缓存的方案要十分慎重。除了限制缓存的大小外，另外要考虑的事情是，进 程之间无法共享内存。如果在进程内使用缓存，这些缓存不可避免地有重复，对物理内存的使用是一种浪费。

如何使用大量缓存，目前比较好的解决方案是采用进程外的缓存，进程自身不存储状态。外部的缓存软件有着良好的缓存过期淘汰策略以及自有的内存管理，不影响 Node 进程的性能。它的好处多多，在Node中主要可以解决以下两个问题。

-  将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更高效。
- 进程之间可以共享缓存。

目前，市面上较好的缓存有 Redis 和 Memcached。Node 模块的生态系统十分完善，这两个产品的客户端都有，通过以下地址可以查看具体使用详情。

#### 关注队列状态

在JavaScript中可以通过队列（数组对象）来完成许多特殊的需求，比如Bagpipe。

列在消费者-生产者模型中经常充当中间产物。这是一个容易忽略的情况，**因为在大多数应用场景下，消费的速度远远大于生产的速度，内存泄漏不易产生。但是一旦消费速度低于生产速度， 将会形成堆积。**

举个实际的例子，有的应用会收集日志。如果欠缺考虑，也许会采用数据库来记录日志。日 志通常会是海量的，数据库构建在文件系统之上，写入效率远远低于文件直接写入，于是会形成数据库写入操作的堆积，而 JavaScript 中相关的作用域也不会得到释放，内存占用不会回落，从而 出现内存泄漏。

遇到这种场景，**表层的解决方案是换用消费速度更高的技术**。在日志收集的案例中，换用文件写入日志的方式会更高效。需要注意的是，如果生产速度因为某些原因突然激增，或者消费速度因为突然的系统故障降低，内存泄漏还是可能出现的。

**深度的解决方案应该是监控队列的长度，一旦堆积，应当通过监控系统产生报警并通知相关人员。**另一个解决方案是任意异步调用都应该包含超时机制，一旦在限定的时间内未完成响应， 通过回调函数传递超时异常，使得任意异步调用的回调都具备可控的响应时间，给消费速度一个下限值。

对于Bagpipe而言，它提供了超时模式和拒绝模式。启用超时模式时，调用加入到队列中就开始计时，超时就直接响应一个超时错误。启用拒绝模式时，当队列拥塞时，新到来的调用会直接响应拥塞错误。这两种模式都能够有效地防止队列拥塞导致的内存泄漏问题。