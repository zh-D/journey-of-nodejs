开那些短时间执行的场景，比如网页应用、命 令行工具等，这类场景由于运行时间短，且运行在用户的机器上，即使内存使用过多或内存泄 漏，也只会影响到终端用户。由于运行时间短，随着进程的退出，内存会释放，几乎没有内存 管理的必要。但随着Node在服务器端的广泛应用，其他语言里存在着的问题在JavaScript中也暴 露出来了。

**本书写到这里算是正式迈进服务器端编程的领域了，内存控制正是在海量请求和长时间运行的前提下进行探讨 的。在服务器端，资源向来就寸土寸金，要为海量用户服务，就得使一切资源都要高效循环利用。 在第3章中，差不多已介绍完Node是如何利用CPU和I/O这两个服务器资源，而本章将介绍在Node 中如何合理高效地使用内存。**

对于性能敏感的服务器端程序，内存管理的好坏、垃圾回收状况是否优良，都会对服务构成 影响。而在Node中，这一切都与Node的JavaScript执行引擎V8息息相关。

### Node 与 V8 

Node在JavaScript的执行上直接受益于V8，可以随着V8的升级就能享受到更好的性能或新的 语言特性（如ES5和ES6）等，同时也受到V8的一些限制，尤其是本章要重点讨论的内存限制。

### V8 的内存限制

在一般的后端开发语言中，在基本的内存使用上没有什么限制，然而在Node中通过JavaScript 使用内存时就会发现只能使用部分内存（64位系统下约为1.4 GB，32位系统下约为0.7 GB）。在 这样的限制下，将会导致Node无法直接操作大内存对象，比如无法将一个2 GB的文件读入内存 中进行字符串分析处理，即使物理内存有32 GB。这样在单个Node进程的情况下，计算机的内存 资源无法得到充足的使用。

尽管在服务器端操作大内存也不是常见的需求场景，但有了限制之后，我们的行为就如同带 着镣铐跳舞，如果在实际的应用中不小心触碰到这个界限，会造成进程退出。要知晓V8为何限 制了内存的用量，则需要回归到V8在内存使用上的策略。知晓其原理后，才能避免问题并更好地进行内存管理。

### V8 的对象分配

heapTotal和heapUsed是V8的堆内存 使用情况，前者是已申请到的堆内存，后者是当前使用的量。

**当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的堆空闲内存不够分配新的对象，将继续申请堆内存，直到堆的大小超过V8的限制为止。**

至于V8为何要限制堆的大小，表层原因为V8最初为浏览器而设计，不太可能遇到用大量内存的场景。对于网页来说，V8的限制值已经绰绰有余。深层原因是V8的垃圾回收机制的限制。 按官方的说法，以 1.5 GB 的垃圾回收堆内存为例，V8做一次小的垃圾回收需要50毫秒以上，做一次非增量式的垃圾回收甚至要1秒以上。这是垃圾回收中引起JavaScript线程暂停执行的时间，在 这样的时间花销下，应用的性能和响应能力都会直线下降。这样的情况不仅仅后端服务无法接受， 前端浏览器也无法接受。因此，在当时的考虑下直接限制堆内存是一个好的选择。

当然，这个限制也不是不能打开，V8依然提供了选项让我们使用更多的内存。Node在启动 时可以传递--max-old-space-size或--max-new-space-size来调整内存限制的大小，示例如下：

```javascript
node --max-old-space-size=1700 test.js // 单位为MB
// 或者
node --max-new-space-size=1024 test.js // 单位为KB
```

### V8 的垃圾回收机制

V8的内存分代

Scavenge算法

Mark-Sweep & Mark-Compact

Incremental Marking

### 看垃圾回收日志

查看垃圾回收日志的方式主要是在启动时添加--trace_gc参数。

通过在Node启动时使用--prof参数，可以得到V8执行时的性能分析数据，其中包含了垃圾 回收执行时占用的时间。

V8提供了linux-tick-processor工具用于统计日志信息。该工具可以从Node源码的 deps/v8/tools目录下找到，Windows下的对应命令文件为windows-tick-processor.bat。将该目录添 加到环境变量PATH中，即可直接调用。